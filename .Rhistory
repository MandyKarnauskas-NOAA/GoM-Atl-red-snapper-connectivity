load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_CODES/FINAL_MAPPING_RESULTS_ext.RData")        #  Fwith_platform is index to be used
head(mat)
#plotonmap(mat$Fwith_resid, mat$statlon, mat$statlat, 15, 0.9, addplus=T); text(-90.5,26.25, "index of fecundity")
plotonmap(mat$Ftotal, mat$statlon, mat$statlat, 15, 0.9, addplus=T); text(-90.5,26.25, "index of fecundity")
#plotonmaphires(mat$Ftotal, mat$statlon, mat$statlat, 15, 0.9, addplus=T, adjlab=0.4)
dat <- data.frame(cbind(mat$statlon, mat$statlat, mat$Ftotal))
names(dat) <- c("lon", "lat", "N")
################################################################################
co <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/CMS_input_files/redSnapperSett_GOM_ATL_hires.xyz", header=F)
################  plot original recruitment habitat grid cells  ################
plot(1, xlim=c(-98,-81), ylim=c(24,31))
for (j in unique(co[,3]))  {
m <- co[which(co[,3]==j),]; polygon(m, col=j)
text(mean(m[,1]), mean(m[,2]), m[1,3], cex=0.6)      }
points(dat$lon, dat$lat, pch=19, cex=0.5)             # release locations
##########  get polygon numbers for release locations  ##############
pts = SpatialPoints(cbind(dat$lon, dat$lat))
m <- co[which(co[,3]==1), ]
m <- rbind(m, m[1,])
oldpol <- Polygons(list(Polygon(cbind(m[,1],m[,2]))), ID=1)
for (j in 2:max(co$V3))  {
m <- co[which(co[,3]==j), ]
m <- rbind(m, m[1,])
newpol <- Polygons(list(Polygon(cbind(m[,1],m[,2]))), ID=j)
oldpol <- c(oldpol, newpol)           }
pol = SpatialPolygons(oldpol)
polynams <- over(pts, pol)
rel <- cbind(polynams, dat)
rel
points(rel$lon, rel$lat, pch=19, cex=0.5, col=rel$polynams/rel$polynams+1)
############ find center point of each polygon  ######
ctrslat <- tapply(co$V2, co$V3, mean)
ctrslon <- tapply(co$V1, co$V3, mean)
points(ctrslon, ctrslat, pch=20, cex=2)
##############  label release site with closest polygon number  ############
for (i in 1:nrow(rel)) {
if (is.na(rel$polynams[i])) {
rel$polynams[i] <- which.min(abs(rel$lon[i]-ctrslon) + abs(rel$lat[i]-ctrslat))  } }
points(rel$lon, rel$lat, pch=19, cex=0.5, col=rel$polynams/(rel$polynams+1))
##########  plot new grid cells  #########################
plot(1, xlim=c(-98,-81), ylim=c(24,31))
for (j in unique(co[,3]))  {
m <- co[which(co[,3]==j),]; polygon(m, lwd=1)
text(m[1,1], m[1,2], m[1,3], cex=0.6)         }
map('usa', add=T)
cols <- rainbow(102)
points(rel$lon, rel$lat, pch=19, cex=0.5, col=cols[rel$polynams])    #  check calcs
points(rel$lon, rel$lat, pch=19, cex=0.5, col=rel$polynams)
###############################     ADD DEPTH      ##################################################
###  !!!! NOTE !!!!
###  Important to use nest from simulation to be run to avoid particles being trapped below surface
#
#nc <- nc_open("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/nest_1_20080501000000_HYCOM150.nc")
nc <- nc_open("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/nest_1_20070701000000.nc")          # this is SABGOM nest_1
v1 <- nc$var[[1]]
u <- ncvar_get(nc, v1)
dim(u)
v1 <- nc$var[[2]]
v <- ncvar_get(nc, v1)
dim(v)
nc_close(nc)
lon <- nc$var[[1]]$dim[[1]]$vals - 360
lat <- nc$var[[1]]$dim[[2]]$vals
dep <- nc$var[[1]]$dim[[3]]$vals
cur <- sqrt(u^2 + v^2)
image(lon, lat, cur[,,1])
image(lon, lat, cur[,,1], xlim=c(-100, -80), ylim=c(24,31))
rel$depest <- NA
for (i in 1:nrow(rel)) {  rel$depest[i] <- dep[max(which(!is.na(u[which.min(abs(lon - rel$lon[i])), which.min(abs(lat - rel$lat[i])),])))] }
head(rel)                 # warnings OK here!
points(rel$lon, rel$lat, pch=19, col=is.na(rel$depest))
rel$depest[is.na(rel$depest)] <- 0
table(rel$depest)
hist(rel$depest)
length(which(rel$depest<45))
length(which(rel$depest>=45))
rel$spawndep <- rel$depest - 5       # set spawning 5m above sea floor
rel$spawndep[which(rel$spawndep > 45)] <- 45
minspawndep <- 13                    #  set minimum spawning depth here -- need to check
length(which(rel$depest<=minspawndep))
dim(rel)
tapply(rel$N, rel$depest<=minspawndep, sum)   # number of particles lost by setting min spawning depth
rel <- rel[which(rel$depest>minspawndep),]
dim(rel)
plot(rel$depest, rel$spawndep)
table(rel$spawndep < rel$depest)
table(rel$spawndep)
table(rel$depest, rel$spawndep)
plotonmap(rel$spawndep, rel$lon, rel$lat, 15, 0.6)
cols <- rainbow(102)
points(rel$lon, rel$lat, pch=19, cex=1.5, col=cols[rel$spawndep])
################################################################################
###########   only run this section after initial Gulf-wide run   ##############
###########   cut out release areas which do not supply S Atl     ##############
# polygon 62 is first to have successful recruitment to S Atl
# polygon 46 is first FL polygon -- cutoff for scaling abundance E/W coast
rel <- rel[which(rel$polynams >= 46),]        # uncomment here to apply cutoff
plotonmap(rel$spawndep, rel$lon, rel$lat, 15, 0.6)
plot(1, xlim=c(-98,-81), ylim=c(24,31))
map('usa', add=T)
cols <- rainbow(102)
points(rel$lon, rel$lat, pch=19, cex=0.5, col=cols[rel$polynams])
points(rel$lon, rel$lat, pch=19, cex=0.5, col=rel$polynams)
abline(v=(-89))
########################     TEMPORAL INFORMATION      #########################
days <- as.Date(format("2004-01-01"))+0:364        #  modify starting year here
days
sp <- data.frame(substr(days, 1, 4))
names(sp) <- "yr"
sp$yr <- as.numeric(as.character(sp$yr))
sp$mo <- as.numeric(as.character(substr(days, 6, 7)))
sp$da <- as.numeric(as.character(substr(days, 9, 10)))
sp$doy <- (1:365)/365
sp
lis <- sp[seq(1, length(days), 6), ]               # releases every 6 days
head(lis)
#  spawning relationship from Porch et al. 2015
lis$spawnact <- (lis$doy/0.536)^(0.536/0.024) * exp((0.536-lis$doy)/0.024)
plot(lis$doy, lis$spawnact)
cutoff <- 0.15; abline(h=cutoff)                   # determine cutoff here
sum(lis$spawnact[which(lis$spawnact > cutoff)]) / sum(lis$spawnact)   # calculate percentile spawning activity included with given cutoff
lis <- lis[which(lis$spawnact > cutoff), ]
points(lis$doy, lis$spawnact, col=2, cex=0.8)      # check cutoff
table(lis$yr)
table(lis$yr, lis$mo)
dim(lis)
lis2 <- lis
#for (i in 2005:2010) {                             #  for multiple years
#   lis2$yr <- i
#   lis <- rbind(lis, lis2) }
dim(lis)
table(lis$yr, lis$mo)
table(lis$yr)
mean(table(lis$yr))
plot(lis$doy, lis$spawnact)
plot(lis$spawnact)
lis <- lis[-c(4)]
head(lis)
###############  input spatial site information (from above)  ###################
rel1 <- rel[-c(5)]
head(rel1)
m <- rel1       # 'm' is list of release sites with columns: polygon, lon, lat, number of releases
head(m)
m$N <- m$N * 100 #  - SCALE AS NECESSARY  - scaling up dramatically so that we can reduce to achieve desired ratio with Atl
mean(m$N); min(m$N); max(m$N)
which(m$N==0)
prod(nrow(lis), nrow(m))
###################### now, making the release file ############################
mat <- as.data.frame(matrix(data=NA, nrow=nrow(lis)*nrow(m), ncol=9))   # empty matrix to be filled
mat[,1] <- rep(m[,1], nrow(lis))                                        # column 1: release polygon number
mat[,2] <- rep(m[,2], nrow(lis))                                        # column 2: release longitude
mat[,3] <- rep(m[,3], nrow(lis))                                        # column 3: release latitude
mat[,4] <- rep(m[,5], nrow(lis))                                        # column 4: release depth
mat[,5] <- rep(m[,4], nrow(lis))                                        # column 5: number of particles per release
mat <- mat[order(mat[,1], mat[,5], mat[,3], mat[,2]), ] # !!!!  CHECK THIS WITH NEW DATA   !!!!                                # resort matrix
# mat
mat[,6] <- rep(lis[,1], nrow(m))                                        # column 6: release year
mat[,7] <- rep(lis[,2], nrow(m))                                        # column 7: release month
mat[,8] <- rep(lis[,3], nrow(m))                                        # column 8: release day
mat[,9] <- 0                                                            # column 9: release hour
mat[,10] <- rep(lis[,4], nrow(m))                                       # column 10: scale by spawning activity!!!!
sum(mat[,5])
mat <- mat[order(mat[,6], mat[,7], mat[,8]), ] # !!!!  REORDER SO DATES ARE TOGETHER   !!!!
head(mat)
mat$V5 <- round(mat$V5 * mat$V10)
sum(mat[,5])
head(mat)
matfin <- mat[-c(10)]
head(matfin)
dim(matfin)
table((matfin$V5 >0))
table((matfin$V5 >0))[1] / nrow(matfin)     # this is % lost to rounding down to zero
matfin <- matfin[which(matfin$V5 >0),]
head(matfin)
dim(matfin)
mean(matfin$V5); min(matfin$V5); max(matfin$V5)
sum(matfin$V5)                              # currently at 3 million particles -- will reduce when combined
# double check
table(matfin$V6, matfin$V7)
table(matfin$V6)
matplot(table(matfin$V7, matfin$V6), type="l")
diff(table(matfin$V6))
tapply(matfin$V5, list(matfin$V6, matfin$V7), sum)
matplot(tapply(matfin$V5, list(matfin$V7, matfin$V6), sum), type="l")
f <- which(matfin$V6==2004 & matfin$V7 == 9 & matfin$V8 == 27); length(f)   # non-peak spawning
plotonmap(matfin$V5[f]/10, matfin$V2[f], matfin$V3[f], cexnum=0.6, pchnum=15)
f <- which(matfin$V6==2004 & matfin$V7 == 6 & matfin$V8 == 23); length(f)   # peak spawning
plotonmap(matfin$V5[f]/10, matfin$V2[f], matfin$V3[f], cexnum=0.6, pchnum=15)
#############################  save output  ####################################
getwd()
matfinGOM <- matfin
save(matfinGOM, file="C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/GOMreleaseForScaling_SABGOM.RData")
####################   END GOM RELEASE LOCATIONS   #############################
################################################################################
################################################################################
############   GoM-ATL scaled red snapper release file for CMS  ################
############   M. Karnauskas Sep 12, 2019                       ################
#
#  code takes output from independent regional maps for GoM and Atl
#  scales release files according to ratios reported in surveys done in both basins
#  for use in full GoM-Atl simulation
################################################################################
rm(list=ls())
install.packages("maps")
library(maps)
###  Step 1: calculate the fecundity of "average fish" in GoM vs Atl
yr <- 2015    # set reference year
ages <- 1:20
BF <- 1.732*(1-exp(-0.29*ages)) ^ 6.047
plot(ages, BF)
#####  Atlantic
NAAatl <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/SA.Nage.csv", sep=",", header=T)
NAAatl[which(NAAatl$year == yr),1]                  # check ref year
vecATL <- NAAatl[which(NAAatl$year == yr),2:21]        # extract NAA vector
BFatl <- sum(vecATL*BF)/sum(vecATL)                       # average fecundity per fish in Atl
#####  Gulf
NAAgom <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/Gulf_NAA_SEDAR52.csv", sep=",", header=T, skip=1)
NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1),9]                    # check ref year
vecGOM <- NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1), 13:32]        # extract NAA vector; caution with 2-area model
BFgom <- sum(vecGOM*BF)/sum(vecGOM)                                          # average fecundity per fish in eastern GoM
vec <- data.frame(t(rbind(vecATL/sum(vecATL), vecGOM/sum(vecGOM))))
barplot(t(vec), beside=T, legend=c("GOM", "ATL"), col=c(2,3), args.legend=list(x="top"), xlab="age classes", ylab="relative abundance")
BFgom     # weighted average - relative fecundity of a fish in the GOM
BFatl     # weighted average - relative fecundity of a fish in the ATL
###  Step 2: calculate relative fecundity present in Gulf, Atl
# input order: GULF, ATL           # REMEMBER: this is on a per-area basis!
ratio <-      c(1.26, 1.83)        # input ratio of abundance from independent fisheries surveys
# these measures should be considered as representing per unit-area basis
fecGOM <- BFgom * ratio[1]        # relative fecundity per unit area GOM
fecATL <- BFatl * ratio[2]        # relative fecundity per unit area ATL
par(mfrow=c(2,1))
barplot(ratio, names.arg=c("GoM", "Atl"), main="relative population abundance per unit area\n(ratios reported from Ted)"); abline(0,0)
barplot(c(fecGOM, fecATL), names.arg=c("GoM", "Atl"), main="relative fecundity per unit area"); abline(0,0)
### Step 3: import independent maps and scale them to known ratios calculated above
rm(list=ls())
if (!"maps" %in% installed.packages()) install.packages("maps", repos='http://cran.us.r-project.org')
library(maps)
yr <- 2015    # set reference year
ages <- 1:20
BF <- 1.732*(1-exp(-0.29*ages)) ^ 6.047
plot(ages, BF)
#####  Atlantic
NAAatl <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/SA.Nage.csv", sep=",", header=T)
################################################################################
rm(list=ls())
if (!"maps" %in% installed.packages()) install.packages("maps", repos='http://cran.us.r-project.org')
library(maps)
###  Step 1: calculate the fecundity of "average fish" in GoM vs Atl
yr <- 2015    # set reference year
ages <- 1:20
BF <- 1.732*(1-exp(-0.29*ages)) ^ 6.047
plot(ages, BF)
#####  Atlantic
NAAatl <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/SA.Nage.csv", sep=",", header=T)
NAAatl[which(NAAatl$year == yr),1]                  # check ref year
vecATL <- NAAatl[which(NAAatl$year == yr),2:21]        # extract NAA vector
BFatl <- sum(vecATL*BF)/sum(vecATL)                       # average fecundity per fish in Atl
#####  Gulf
NAAgom <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/Gulf_NAA_SEDAR52.csv", sep=",", header=T, skip=1)
NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1),9]                    # check ref year
vecGOM <- NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1), 13:32]        # extract NAA vector; caution with 2-area model
BFgom <- sum(vecGOM*BF)/sum(vecGOM)                                          # average fecundity per fish in eastern GoM
vec <- data.frame(t(rbind(vecATL/sum(vecATL), vecGOM/sum(vecGOM))))
barplot(t(vec), beside=T, legend=c("GOM", "ATL"), col=c(2,3), args.legend=list(x="top"), xlab="age classes", ylab="relative abundance")
BFgom     # weighted average - relative fecundity of a fish in the GOM
BFatl     # weighted average - relative fecundity of a fish in the ATL
# input order: GULF, ATL           # REMEMBER: this is on a per-area basis!
ratio <-      c(1.26, 1.83)        # input ratio of abundance from independent fisheries surveys
# these measures should be considered as representing per unit-area basis
fecGOM <- BFgom * ratio[1]        # relative fecundity per unit area GOM
fecATL <- BFatl * ratio[2]        # relative fecundity per unit area ATL
par(mfrow=c(2,1))
barplot(ratio, names.arg=c("GoM", "Atl"), main="relative population abundance per unit area\n(ratios reported from Ted)"); abline(0,0)
barplot(c(fecGOM, fecATL), names.arg=c("GoM", "Atl"), main="relative fecundity per unit area"); abline(0,0)
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/GOMreleaseForScaling_SABGOM.RData")
GOM <- matfinGOM
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/ATLreleaseForScaling_SABGOM.RData")
ATL <- matS
# check how many millions of particles present in each file
sum(GOM$V5)/10^6
sum(KEY$V5)/10^6
sum(ATL$V5)/10^6
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/GOMreleaseForScaling_SABGOM.RData")
GOM <- matfinGOM
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/ATLreleaseForScaling_SABGOM.RData")
ATL <- matS
# check how many millions of particles present in each file
sum(GOM$V5)/10^6
# check how many millions of particles present in each file
sum(GOM$V5)/10^6
sum(ATL$V5)/10^6
areaGOM <- length(unique(paste(GOM$V2, GOM$V3)))
areaKEY <- length(unique(paste(KEY$V2, KEY$V3)))
areaGOM <- length(unique(paste(GOM$V2, GOM$V3)))
# Atlantic is not entire map -- subset grid cells within sampling
ATL2 <- ATL[which(ATL$V3 >= 28.0069 & ATL$V3 <= 30.5296), ]
dim(ATL); dim(ATL2)
areaATL <- length(unique(paste(ATL2$V2, ATL2$V3)))
areaGOM; areaATL   # areas in terms of number of 10^km cells
paste(ATL2$V2, ATL2$V3)
areaGOM; areaATL   # areas in terms of number of 10^km cells
# calculate constants for scaling
# solve for constant based on relative fecundity per unit area, relative fecundity metric within regional map, and area of regional map
const_scaler <- 10^5    # set so that final output has reasonable number of particles
constGOM <- areaGOM * fecGOM / sum(GOM$V5) * const_scaler      # check this calculation later!!!!!
constGOM <- areaGOM * fecGOM / sum(GOM$V5) * const_scaler      # check this calculation later!!!!!
constATL <- areaATL * fecATL / sum(ATL2$V5) * const_scaler
constGOM
constKEY
constGOM
constATL
unscaled <- rbind(GOM, KEY, ATL)
unscaled <- rbind(GOM, ATL)
dim(unscaled)
GOMsc <- GOM
GOMsc <- GOM
ATLsc <- ATL
GOMsc$V5 <- round(GOMsc$V5 * constGOM)
GOMsc$V5 <- round(GOMsc$V5 * constGOM)
ATLsc$V5 <- round(ATLsc$V5 * constATL)
scaled <- rbind(GOMsc, KEYsc, ATLsc)
scaled <- rbind(GOMsc, ATLsc)
dim(scaled)
which(scaled$V5==0)
par(mfrow=c(1,3), mex=0.8)
par(mfrow=c(1,3), mex=0.8)
barplot(c(sum(GOM$V5), sum(ATL$V5)), names.arg=c("GoM", "Atl"), main="unscaled", ylab=""); abline(0,0)
barplot(c(fecGOM,  fecATL), names.arg=c("GoM",  "Atl"), main="specified ratio", ylab=""); abline(0,0)
#barplot(c(sum(GOMsc$V5)/areaGOM, sum(KEYsc$V5)/areaKEY, sum(ATLsc$V5)/areaATL), names.arg=c("GoM", "Keys", "Atl"), main="scaled by area", ylab="relative total population fecundity"); abline(0,0)
barplot(c(sum(GOMsc$V5), sum(KEYsc$V5), sum(ATLsc$V5)), names.arg=c("GoM", "Keys", "Atl"), main="scaled", ylab=""); abline(0,0)
#barplot(c(sum(GOMsc$V5)/areaGOM, sum(KEYsc$V5)/areaKEY, sum(ATLsc$V5)/areaATL), names.arg=c("GoM", "Keys", "Atl"), main="scaled by area", ylab="relative total population fecundity"); abline(0,0)
barplot(c(sum(GOMsc$V5), sum(ATLsc$V5)), names.arg=c("GoM", "Atl"), main="scaled", ylab=""); abline(0,0)
ratio                # ratio reported from Ted
ratio[1]/ratio[2]
(sum(GOMsc$V5)) / (sum(ATLsc$V5))
(sum(GOMsc$V5)/areaGOM) / (sum(ATLsc$V5)/areaATL)
#  plot results to check
windows()
sc2 <- scaled[which(scaled$V6==2004 & scaled$V7==5 & scaled$V8==12),]
x <- sc2$V5
pos <- c(0.005,  0.05, 0.1, 0.2, 0.5, 1, 2, 4, 5, 10, 50, 100, 200, 500, 1000)
a <- floor(min(x))
b <- max((x)-a)*1.03
pind <- round((x-a)/b*100+1); print(min(pind)); print(max(pind))
cols <- c(rainbow(30, start=0.82, end=0.99), rainbow(70, start=0.01, end=0.17))[100:1]
map('state', fill = 1, interior=F, col = gray(0.95), ylim=c(23.0, 35), xlim=c(-88,-76))
points(sc2$V2, sc2$V3, col=cols[pind], pch=15, cex=0.8)
box(); axis(1); axis(2)
xloc <- seq(-86, -78, length.out=100)
for (j in 1:100) {   polygon(c(xloc[j], xloc[j+1],xloc[j+1], xloc[j]), c(23.5,23.5,24.0,24.0), col=cols[j], border=NA) }
w <- which.min(abs(((max(x)-min(x))/6) - pos))
if(-pos[w]<min(x)) { xx <- seq(0, max(x), pos[w]); xx <- xx[xx>min(x)] } else {  xx <- c(seq(-pos[w], min(x), -pos[w]), seq(0, max(x), pos[w])) }
text(xloc[round((xx-a)/b*100+1)], y=23.2, xx, pos=2)
mtext(side=3, line=1.5, "scaled fecundity map", cex=1.3, font=2)
lines(x=c(-81.5, -79.5), rep(28.0069,2))
lines(x=c(-81.5, -79.5), rep(30.5296,2))
lines(x=rep(-81.5, 2), c(28.0069, 30.5296))
lines(x=rep(-79.5, 2), c(28.0069, 30.5296))
ratio                # ratio reported from Ted
ratio[1]/ratio[2]
(sum(GOMsc$V5)) / (sum(ATLsc$V5))
(sum(GOMsc$V5)/areaGOM) / (sum(ATLsc$V5)/areaATL)
ratio[1]/ratio[2]
(sum(GOMsc$V5)) / (sum(KEYsc$V5))
(sum(GOMsc$V5)/areaGOM) / (sum(KEYsc$V5)/areaKEY)
areaGOM; areaATL   # areas in terms of number of 10^km cells
# calculate constants for scaling
# solve for constant based on relative fecundity per unit area, relative fecundity metric within regional map, and area of regional map
const_scaler <- 10^5    # set so that final output has reasonable number of particles
constGOM <- areaGOM * fecGOM / sum(GOM$V5) * const_scaler      # check this calculation later!!!!!
constATL <- areaATL * fecATL / sum(ATL2$V5) * const_scaler
constGOM
constATL
unscaled <- rbind(GOM, ATL)
dim(unscaled)
GOMsc <- GOM
ATLsc <- ATL
GOMsc$V5 <- round(GOMsc$V5 * constGOM)
ATLsc$V5 <- round(ATLsc$V5 * constATL)
scaled <- rbind(GOMsc, ATLsc)
dim(scaled)
which(scaled$V5==0)
par(mfrow=c(1,3), mex=0.8)
barplot(c(sum(GOM$V5), sum(ATL$V5)), names.arg=c("GoM", "Atl"), main="unscaled", ylab=""); abline(0,0)
barplot(c(fecGOM,  fecATL), names.arg=c("GoM",  "Atl"), main="specified ratio", ylab=""); abline(0,0)
#barplot(c(sum(GOMsc$V5)/areaGOM, sum(KEYsc$V5)/areaKEY, sum(ATLsc$V5)/areaATL), names.arg=c("GoM", "Keys", "Atl"), main="scaled by area", ylab="relative total population fecundity"); abline(0,0)
barplot(c(sum(GOMsc$V5), sum(ATLsc$V5)), names.arg=c("GoM", "Atl"), main="scaled", ylab=""); abline(0,0)
ratio                # ratio reported from Ted
ratio[1]/ratio[2]
(sum(GOMsc$V5)) / (sum(ATLsc$V5))
(sum(GOMsc$V5)/areaGOM) / (sum(ATLsc$V5)/areaATL)
BFgom     # weighted average - relative fecundity of a fish in the GOM
BFatl     # weighted average - relative fecundity of a fish in the ATL
# input order: GULF, ATL           # REMEMBER: this is on a per-area basis!
ratio <-      c(1.26, 1.83)        # input ratio of abundance from independent fisheries surveys
# these measures should be considered as representing per unit-area basis
fecGOM <- BFgom * ratio[1]        # relative fecundity per unit area GOM
fecATL <- BFatl * ratio[2]        # relative fecundity per unit area ATL
par(mfrow=c(2,1))
barplot(ratio, names.arg=c("GoM", "Atl"), main="relative population abundance per unit area\n(ratios reported from Ted)"); abline(0,0)
barplot(c(fecGOM, fecATL), names.arg=c("GoM", "Atl"), main="relative fecundity per unit area"); abline(0,0)
################################################################################
############   GoM-ATL scaled red snapper release file for CMS  ################
############   M. Karnauskas Sep 12, 2019                       ################
#
#  code takes output from independent regional maps for GoM and Atl
#  scales release files according to ratios reported in surveys done in both basins
#  for use in full GoM-Atl simulation
################################################################################
rm(list=ls())
if (!"maps" %in% installed.packages()) install.packages("maps", repos='http://cran.us.r-project.org')
library(maps)
###  Step 1: calculate the fecundity of "average fish" in GoM vs Atl
yr <- 2015    # set reference year
ages <- 1:20
BF <- 1.732*(1-exp(-0.29*ages)) ^ 6.047
plot(ages, BF)
#####  Atlantic
NAAatl <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/SA.Nage.csv", sep=",", header=T)
NAAatl[which(NAAatl$year == yr),1]                  # check ref year
vecATL <- NAAatl[which(NAAatl$year == yr),2:21]        # extract NAA vector
BFatl <- sum(vecATL*BF)/sum(vecATL)                       # average fecundity per fish in Atl
#####  Gulf
NAAgom <- read.table("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/Gulf_NAA_SEDAR52.csv", sep=",", header=T, skip=1)
NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1),9]                    # check ref year
vecGOM <- NAAgom[which(NAAgom$Time == yr & NAAgom$Area==1), 13:32]        # extract NAA vector; caution with 2-area model
BFgom <- sum(vecGOM*BF)/sum(vecGOM)                                          # average fecundity per fish in eastern GoM
vec <- data.frame(t(rbind(vecATL/sum(vecATL), vecGOM/sum(vecGOM))))
barplot(t(vec), beside=T, legend=c("GOM", "ATL"), col=c(2,3), args.legend=list(x="top"), xlab="age classes", ylab="relative abundance")
BFgom     # weighted average - relative fecundity of a fish in the GOM
BFatl     # weighted average - relative fecundity of a fish in the ATL
###  Step 2: calculate relative fecundity present in Gulf, Atl
# input order: GULF, ATL           # REMEMBER: this is on a per-area basis!
ratio <-      c(1.26, 1.83)        # input ratio of abundance from independent fisheries surveys
# these measures should be considered as representing per unit-area basis
fecGOM <- BFgom * ratio[1]        # relative fecundity per unit area GOM
fecATL <- BFatl * ratio[2]        # relative fecundity per unit area ATL
par(mfrow=c(2,1))
barplot(ratio, names.arg=c("GoM", "Atl"), main="relative population abundance per unit area\n(ratios reported from Ted)"); abline(0,0)
barplot(c(fecGOM, fecATL), names.arg=c("GoM", "Atl"), main="relative fecundity per unit area"); abline(0,0)
### Step 3: import independent maps and scale them to known ratios calculated above
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/GOMreleaseForScaling_SABGOM.RData")
GOM <- matfinGOM
load("C:/Users/mandy.karnauskas/Desktop/RS_FATEproject/MASTER_codes/ATLreleaseForScaling_SABGOM.RData")
ATL <- matS
# check how many millions of particles present in each file
sum(GOM$V5)/10^6
sum(ATL$V5)/10^6
areaGOM <- length(unique(paste(GOM$V2, GOM$V3)))
# Atlantic is not entire map -- subset grid cells within sampling
ATL2 <- ATL[which(ATL$V3 >= 28.0069 & ATL$V3 <= 30.5296), ]
dim(ATL); dim(ATL2)
areaATL <- length(unique(paste(ATL2$V2, ATL2$V3)))
areaGOM; areaATL   # areas in terms of number of 10^km cells
# calculate constants for scaling
# solve for constant based on relative fecundity per unit area, relative fecundity metric within regional map, and area of regional map
const_scaler <- 10^5    # set so that final output has reasonable number of particles
constGOM <- areaGOM * fecGOM / sum(GOM$V5) * const_scaler      # check this calculation later!!!!!
constATL <- areaATL * fecATL / sum(ATL2$V5) * const_scaler
constGOM
constATL
unscaled <- rbind(GOM, ATL)
dim(unscaled)
GOMsc <- GOM
ATLsc <- ATL
GOMsc$V5 <- round(GOMsc$V5 * constGOM)
ATLsc$V5 <- round(ATLsc$V5 * constATL)
scaled <- rbind(GOMsc, ATLsc)
dim(scaled)
which(scaled$V5==0)
par(mfrow=c(1,3), mex=0.8)
barplot(c(sum(GOM$V5), sum(ATL$V5)), names.arg=c("GoM", "Atl"), main="unscaled", ylab=""); abline(0,0)
barplot(c(fecGOM,  fecATL), names.arg=c("GoM",  "Atl"), main="specified ratio", ylab=""); abline(0,0)
#barplot(c(sum(GOMsc$V5)/areaGOM, sum(KEYsc$V5)/areaKEY, sum(ATLsc$V5)/areaATL), names.arg=c("GoM", "Keys", "Atl"), main="scaled by area", ylab="relative total population fecundity"); abline(0,0)
barplot(c(sum(GOMsc$V5), sum(ATLsc$V5)), names.arg=c("GoM", "Atl"), main="scaled", ylab=""); abline(0,0)
# check ratios
ratio                # ratio reported from Ted
ratio[1]/ratio[2]
(sum(GOMsc$V5)) / (sum(ATLsc$V5))
(sum(GOMsc$V5)/areaGOM) / (sum(ATLsc$V5)/areaATL)
sc3 <- unscaled[which(unscaled$V6==2004 & unscaled$V7==5 & unscaled$V8==12),]
x <- sc3$V5
pos <- c(0.005,  0.05, 0.1, 0.2, 0.5, 1, 2, 4, 5, 10, 50, 100, 500, 1000)
a <- floor(min(x))
b <- max((x)-a)*1.03
pind <- round((x-a)/b*100+1); print(min(pind)); print(max(pind))
cols <- c(rainbow(30, start=0.82, end=0.99), rainbow(70, start=0.01, end=0.17))[100:1]
map('state', fill = 1, interior=F, col = gray(0.95), ylim=c(23.0, 35), xlim=c(-88,-76))
points(sc2$V2, sc2$V3, col=cols[pind], pch=15, cex=0.8)
box(); axis(1); axis(2)
xloc <- seq(-86, -78, length.out=100)
for (j in 1:100) {   polygon(c(xloc[j], xloc[j+1],xloc[j+1], xloc[j]), c(23.5,23.5,24.0,24.0), col=cols[j], border=NA) }
sc2 <- scaled[which(scaled$V6==2004 & scaled$V7==5 & scaled$V8==12),]
x <- sc2$V5
pos <- c(0.005,  0.05, 0.1, 0.2, 0.5, 1, 2, 4, 5, 10, 50, 100, 200, 500, 1000)
a <- floor(min(x))
b <- max((x)-a)*1.03
pind <- round((x-a)/b*100+1); print(min(pind)); print(max(pind))
cols <- c(rainbow(30, start=0.82, end=0.99), rainbow(70, start=0.01, end=0.17))[100:1]
map('state', fill = 1, interior=F, col = gray(0.95), ylim=c(23.0, 35), xlim=c(-88,-76))
points(sc2$V2, sc2$V3, col=cols[pind], pch=15, cex=0.8)
box(); axis(1); axis(2)
xloc <- seq(-86, -78, length.out=100)
for (j in 1:100) {   polygon(c(xloc[j], xloc[j+1],xloc[j+1], xloc[j]), c(23.5,23.5,24.0,24.0), col=cols[j], border=NA) }
w <- which.min(abs(((max(x)-min(x))/6) - pos))
if(-pos[w]<min(x)) { xx <- seq(0, max(x), pos[w]); xx <- xx[xx>min(x)] } else {  xx <- c(seq(-pos[w], min(x), -pos[w]), seq(0, max(x), pos[w])) }
text(xloc[round((xx-a)/b*100+1)], y=23.2, xx, pos=2)
mtext(side=3, line=1.5, "scaled fecundity map", cex=1.3, font=2)
lines(x=c(-81.5, -79.5), rep(28.0069,2))
lines(x=c(-81.5, -79.5), rep(30.5296,2))
lines(x=rep(-81.5, 2), c(28.0069, 30.5296))
lines(x=rep(-79.5, 2), c(28.0069, 30.5296))
